# 第十二章 Selenium模拟浏览器

​	在之前的学习中，我们了解了Ajax的分析和抓取方式，这其实也是JavaScript动态渲染的页面的一种情形，通过直接分析Ajax，可以直接借助requests库实现数据爬取。

​	JS动态渲染的页面除了Ajax以外，有分页部分由JS生成的(比如中国青年网)，有图形是经过JS计算生成的(ECharts),有虽然是Ajax请求,但是大部分接口是加密参数的(比如淘宝)。

​	为了解决这些问题，我们可以直接使用模拟浏览器运行的方式来实现，做到浏览器看到是什么样，抓取得源码就是什么样，也就是[可见即可爬]()。

​	Python提供了许多模拟浏览器运行的库，例如Selenium、Spalsh、Pyppetter、Playwright等，可以帮助我们实现[可见即可爬]()，有了这些库，就不用再为如何爬取动态渲染的页面发愁了。

​	本章主要以Selenium的使用为例，以Pyppetter的使用为拓展。



## 12.1 Selenium的安装

### 12.1.0 前言

​	在第9章中，我们介绍了Ajax的分析方法，利用Ajax接口可以非常方便地爬取数据。只要找到Ajax接口的规律，就可以通过某些参数构造出对应的请求，自然就能轻松地爬取数据了。

​	但是在很多情况下，Ajax请求的接口包含有加密参数，例如token，sign等，比如说美团的数据

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523094718169.png" alt="image-20220523094718169" style="zoom:67%;" />

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523094755297.png" alt="image-20220523094755297" style="zoom:67%;" />

​	如果不深入分析并找到token参数的构造逻辑，是难以模拟Ajax请求的。

​	通常来说方法有两种：

- 一种是深挖其中的逻辑，把token参数的构造逻辑完全找出来，再用Python代码复现，构造Ajax请求（我们将在第十六章中学习）。
- 另一种是直接模拟浏览器的运行，绕过这个过程，因为在浏览器中是可以看到这个数据的，所以如果能把看到的数据直接爬取下来，当然就能获取对应的信息了。

​	第一种方法难度较高，我们先介绍第二种方法：模拟浏览器的运行，爬取数据。



​	在第11章中，我们介绍了滑动验证码的缺口目标识别方法，但是怎么去拖拽滑块到达缺口目标位置？通常来说方法也有两种：

- 第一种可以通过逆向JS实现，因为滑动验证码的动态效果是由JS动态效果实现，我们可以逆向JS的逻辑来完成拓展，当然难度也非常高。

- 那么第二种也是通过模拟浏览器实现，模拟浏览器用鼠标拖拽滑动验证码到指定位置，这个实现就相当非常简单了。

  

​	综上所述，模拟浏览器的爬虫方式是在处理动态渲染页面中相对比较简单的办法，通常我们会使用一些自动化测试工具来实现模拟浏览器的操作，Selenium就是其中一员。

​	Selenium是一个自动化测试工具，利用它可以驱动浏览器完成特定的操作，例如可以获取浏览器当前呈现的页面的源代码，做到[可见即可爬]()；还可以实现点击、下拉、拖拽等功能，实现滑动验证码、点击验证码的识别。



```makefile
selenium小结
- 概念：基于浏览器自动化的模块
- 自动化：可以通过代码指定一些列的行为动作，然后将其作用到浏览器中。
- selenium和爬虫之间的关联
    - 1.便捷的捕获到任意形式动态加载的数据（可见即可得）
    - 2.实现模拟登录
```

### 12.1.1 下载谷歌驱动

- Chrome浏览器下载地址：https://www.google.cn/intl/zh-CN/chrome/

- Chrome浏览器驱动下载地址：http://chromedriver.storage.googleapis.com/index.html



​	本节以Chrome浏览器为例讲解Selenium的用法。在开始之前，先确保已经正确安装好了Chrome浏览器，安装过程略。

​	安装好Chrome浏览器后，打开Chrome浏览器，找到关于`Google Chrome`。

![image-20220523101240101](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523101240101.png)

找到安装好的Chrome浏览器版本，如我的版本号为 [101.0.4951.67]()

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523101431153.png" alt="image-20220523101431153" style="zoom: 67%;" />





​	根据你的Chrome浏览器版本，下载相应的Chrome浏览器驱动，这里以我的版本号 [101.0.4951.67]()为例，找到与我的版本号[101.0.4951.67]()最相近的驱动版本:

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523101727339.png" alt="image-20220523101727339" style="zoom:50%;" />



​	点击进去，下载对应操作系统（本例为Windows操作系统）的驱动程序压缩包：

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523101915513.png" alt="image-20220523101915513" style="zoom:50%;" />

​	将压缩包解压到指定目录（本例目录`C:\Program Files\Google\Chrome\Application\`）

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523102625598.png" alt="image-20220523102625598" style="zoom:67%;" />

![image-20220523102655131](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523102655131.png)



### 12.1.2 下载Selnium模块

​	直接通过`pip`命令安装。

```python
pip install selenium
```



### 12.1.3 测试selenium

```python
from selenium import webdriver

# 实例化浏览器对象
# executable_path是chrome驱动路径名
browser = webdriver.Chrome(executable_path=r"C:\Program Files\Google\Chrome\Application\chromedriver.exe")
# 使用choreme浏览器请求JD主页
browser.get('https://www.baidu.com/')
print(browser) #<selenium.webdriver.chrome.webdriver.WebDriver (session="72e685b430c56beaf488fbc95ca8e491")>
```

​	执行代码后，会直接跳转出chrome浏览器，同时显示【Chrome正收到自动测试软件的控制】

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523110410467.png" alt="image-20220523110410467" style="zoom: 67%;" />



## 12.2 Selenium的使用

### 12.2.1 初始化浏览器

​	Selenium支持的浏览器非常多，既有Chrome、FireFox、Edge、Safari等PC端的浏览器，也有Android、BlackBerry等移动端的浏览器。

​	我们可以用以下方法初始化浏览器对象：

```python
# 初始化浏览器
driver = webdriver.Chrome(executable_path="驱动路径")
driver = webdriver.Firefox(executable_path="驱动路径")
driver = webdriver.Edge(executable_path="驱动路径")
driver = webdriver.Android()
driver = webdriver.BlackBerry()
```

​	本章所有内容均以chrome为例，如果同学们想测试其他的浏览器，可以自行修改初始化方法。

```python
from selenium import webdriver


# 初始化浏览器
# executable_path是浏览器驱动位置，记得前面加r'',   'r'是防止字符转义的
driver = webdriver.Chrome(executable_path=r'C:\Program Files\Google\Chrome\Application\chromedriver.exe')

print(driver)   
print(type(driver)) 
```

​	![image-20220523112011277](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523112011277.png)

​	这样就完成了浏览器对象的初始化，并将其赋值给了driver。接下来，我们要做的就是调用driver，执行各个方法以模拟浏览器的操作。



​	PS：如果将Chrome驱动的路径添加到环境变量中，如下：

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523112220236.png" alt="image-20220523112220236" style="zoom: 80%;" />

​				在初始化时，可以不用设置`executable_path`参数

​	

```python
from selenium import webdriver

# 初始化浏览器
# executable_path是浏览器驱动位置，记得前面加r'',   'r'是防止字符转义的
driver = webdriver.Chrome()
```



### 12.2.2 访问页面

​	我们可以使用get方法请求网页，向其参数传入要请求的网页的URL即可。

```python
from selenium import webdriver
import time

#  实例化浏览器对象
driver = webdriver.Chrome(executable_path=r"C:\Program Files\Google\Chrome\Application\chromedriver.exe") #executable_path是驱动地址
#  使用choreme浏览器请求JD主页
driver.get('https://www.jd.com/')
```

### 12.2.3 关闭浏览器

```python
#  关闭浏览器
driver.close()
#  退出浏览器对象
driver.quit()
```



### 12.2.4  标签定位	 --重点 

​	Selnium可以驱动浏览器完成各种操作，比如填充表单、模拟点击等；或者当我们要爬取数据的时候，我们要选择对应标签节点的数据。这时候我们就要知道如何定位标签。

​	在之前的学习中，我们掌握了使用`xpath表达式`，`css选择器`等进行标签定位，在Selenium中为我们提供了一系列可以用来定位标签的方法：

|                方法名                |                        用途                        |
| :----------------------------------: | :------------------------------------------------: |
|            find_element()            | 通过指定方法查找指定的一个元素**(需指定两个参数)** |
|           find_elements()            |    通过指定方法查找所有元素**(需指定两个参数)**    |
|     find_element_by_class_name()     |          通过Class name查找指定的一个元素          |
|    find_element_by_css_selector()    |          通过CSS选择器查找指定的一个元素           |
|         find_element_by_id()         |              通过ID查找指定的一个元素              |
|     find_element_by_link_text()      |     通过链接文本获取指定的一个超链接(精确匹配)     |
|        find_element_by_name()        |             通过Name查找指定的一个元素             |
| find_element_by_partial_link_text()  |     通过链接文本获取指定的一个超链接(模糊匹配)     |
|      find_element_by_tag_name()      |            通过标签名查找指定的一个元素            |
|       find_element_by_xpath()        |           通过Xpath语法来指定的一个元素            |
|    find_elements_by_class_name()     |             通过Class name查找所有元素             |
|   find_elements_by_css_selector()    |             通过CSS选择器查找所有元素              |
|        find_elements_by_id()         |                 通过ID查找所有元素                 |
|     find_elements_by_link_text()     |        通过链接文本获取所有超链接(精确匹配)        |
|       find_elements_by_name()        |                通过Name查找所有元素                |
| find_elements_by_partial_link_text() |        通过链接文本获取所有超链接(模糊匹配)        |
|     find_elements_by_tag_name()      |               通过标签名查找所有元素               |
|       find_elements_by_xpath()       |            通过Xpath语法来查找所有元素             |



#### ① 定位单个节点

​	比如我们要定位【新人福利】的标签，可以用以下办法实现：

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523152138032.png" alt="image-20220523152138032" style="zoom:67%;" />

```python
from selenium import webdriver
import time

#  实例化浏览器对象
driver = webdriver.Chrome(executable_path=r"C:\Program Files\Google\Chrome\Application\chromedriver.exe") #executable_path是驱动地址
#  使用choreme浏览器请求JD主页
driver.get('https://www.jd.com/')
#  定位标签
new_coming = driver.find_element_by_xpath(xpath='//*[@id="J_user"]/div/div[2]/a[1]')    # xpath方法
# new_coming = driver.find_element_by_class_name(name="user_profit_lk")     # 根据class属性值
# new_coming = driver.find_element_by_css_selector(css_selector="#J_user > div > div.user_profit > a:nth-child(1)")     #  css选择器

# 输出结果
print(type(new_coming))
print(new_coming.text)

#  休眠10秒
time.sleep(10)
#  关闭浏览器
driver.close()
#  退出浏览器对象
driver.quit()
```

![image-20220523153147306](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523153147306.png)



#### ② 定位全部节点

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220523153234348.png" alt="image-20220523153234348" style="zoom:67%;" />



```python
from selenium import webdriver
import time

#  实例化浏览器对象
driver = webdriver.Chrome(executable_path=r"C:\Program Files\Google\Chrome\Application\chromedriver.exe") #executable_path是驱动地址
#  使用choreme浏览器请求JD主页
driver.get('https://www.jd.com/')
#  定位标签
tags = driver.find_elements_by_xpath(xpath='//*[@id="J_cate"]/ul/li/a')    # xpath方法
# tags = driver.find_elements_by_class_name(name="cate_menu_lk")     # 根据class属性值
# tags = driver.find_elements_by_css_selector(css_selector="#J_cate > ul > li > a")     #  css选择器

# 输出结果
for tag in tags:
    print(tag.text)

#  休眠10秒
time.sleep(10)
#  关闭浏览器
driver.close()
#  退出浏览器对象
driver.quit()
```

#### ③ 用By方法（以定位全部节点为例）

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
import time

#  实例化浏览器对象
driver = webdriver.Chrome(executable_path=r"C:\Program Files\Google\Chrome\Application\chromedriver.exe") #executable_path是驱动地址
#  使用choreme浏览器请求JD主页
driver.get('https://www.jd.com/')
#  定位标签
tags = driver.find_elements(by=By.XPATH, value='//*[@id="J_cate"]/ul/li/a')
# tags = driver.find_elements(by=By.CLASS_NAME, value="cate_menu_lk")     # 根据class属性值
# tags = driver.find_elements(by=By.CSS_SELECTOR, value="#J_cate > ul > li > a")     #  css选择器

# 输出结果
for tag in tags:
    print(tag.text)

#  休眠10秒
time.sleep(10)
#  关闭浏览器
driver.close()
#  退出浏览器对象
driver.quit()
```



#### 练习1：京东爬虫

- 练习题：爬取https://search.jd.com/Search?keyword=%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91&enc=utf-8&wq=%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91&pvid=9670bb8327dc4017b1222a1c0a85e9d6 的全部商品名称（使用selenium）
  - tip1 下载并安装chrome驱动
  - tip2 实例化browser并打开商品页
  - tip3 使用标签定位找到商品名称



```python
代码略
```





### 12.2.5  标签操作  -- 重点

- kw1=c.find_element(By.ID,'kw') 	#  定位标签
  - 对我们找到的标签进行二次操作，不仅可以再次选择子 标签还可以进行其它操作。

#### ① 获取节点信息

​	**重点中的重点**

|                方法名                |               用途               |
| :----------------------------------: | :------------------------------: |
|                kw1.id                |      Selenium所使用的内部ID      |
|    **kw1.get_property('class')**     |        获取元素的属性的值        |
|     **kw1.get_attribute('id')**      |        获取元素的属性的值        |
|           **kw1.location**           |          获取元素的坐标          |
| kw1.location_once_scrolled_into_view | 不滚动且底部对齐并获取元素的坐标 |
|             **kw1.size**             |          获取标签的大小          |
|             kw1.tag_name             |              标签名              |
|             **kw1.text**             |           标签文本内容           |



#### ② 键盘操作（一）

|              方法名              |                 用途                 |
| :------------------------------: | :----------------------------------: |
|           kw1.clear()            |     清除标签的值（通常是输入框）     |
|  **kw1.send_keys('输入内容')**   |    向标签内输入值（通常是输入框）    |
|            kw1.submit            |               提交表单               |
| kw1.key_down(value,element=None) |          按下键盘上的某个键          |
| kw1.key_up(value, element=None)  |          松开键盘上的某个键          |
|        kw1.pause(seconds)        | 暂停所有输入(指定持续时间以秒为单位) |



#### ③ 鼠标操作（一）

|   方法名    |   用途   |
| :---------: | :------: |
| kw1.click() | 点击标签 |



### 实训一：京东搜索关键词

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220524153939635.png" alt="image-20220524153939635" style="zoom: 67%;" />

​	① 使用Selenium跳转到JD首页 https://www.jd.com/

​	② 在输入框内输入关键词

​	③ 点击搜索按钮

​	④ 进入到搜索页后，抓取第一页所有的商品名


```python
from selenium import webdriver
import time

# 京东首页
index_url = 'https://www.jd.com/'

# 初始化浏览器
driver = webdriver.Chrome(executable_path=r'C:\Program Files\Google\Chrome\Application\chromedriver.exe')

# ① 跳转到京东首页
driver.get(index_url)

# ② 在输入框中输入关键词，本例关键词为 笔记本电脑
keyword = '笔记本电脑'
# 定位输入框标签，返回赋值给input_tag
input_tag = driver.find_element_by_xpath('//*[@id="key"]')
# 模拟键盘清空输入框
input_tag.clear()
# 模拟键盘输入关键词
input_tag.send_keys(keyword)

# ③ 点击搜索按钮
# 定位搜索按钮标签，返回赋值给search_button_tag
search_button_tag = driver.find_element_by_xpath('//*[@id="search"]/div/div[2]/button')
# 模拟鼠标点击按钮
search_button_tag.click()
# 休眠3秒
time.sleep(3)


# ④ 抓取第一页所有的商品名
# 解析所有的li标签
li_ls = driver.find_elements_by_xpath('//*[@id="J_goodsList"]/ul/li')
# 遍历li_ls
for li in li_ls:
    # 定位标签
    title_tag = li.find_element_by_xpath('./div/div[3]/a/em')
    # 提取标签的文本值
    title = title_tag.text
    # 输出文本
    print(title)

# 关闭浏览器
driver.close()
driver.quit()
```



<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220524155545125.png" alt="image-20220524155545125" style="zoom: 67%;" />



#### ④ 其他

|         方法名          |           用途           |
| :---------------------: | :----------------------: |
| kw1.screenshot('2.png') | 截取元素形状并保存为图片 |
|  kw1._upload('2.png')   |         上传文件         |
|    kw1.is_displayed     |     判断元素是否显示     |



#### 练习2：截图职教云登陆界面的验证码

​	职教云链接：https://zjy2.icve.com.cn/portal/login.html

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220524160529964.png" alt="image-20220524160529964" style="zoom:50%;" />

![image-20220524160956319](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220524160956319.png)

​	如果用requests库直接去请求职教云的验证码链接【https://zjy2.icve.com.cn/api/common/VerifyCode/index?t=0.10635888205710287】会发现一个问题：

![image-20220524161033480](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220524161033480.png)	结果是一个乱码，这是后台做了一个验证码的混淆，我们直接去请求验证码链接下载图片的方式失败了，那该怎么办呢？



​	Selenium就提供了一个截图的方法，它并不是去请求验证码的链接，而是类似我们平常在用截图软件一样，将验证码截图下来，这样就避免了直接请求验证码链接导致乱码的情况。



```python
from selenium import webdriver
from selenium.webdriver.remote.webelement import WebElement
import time
import cv2


# 职教云首页链接
index_url = 'https://zjy2.icve.com.cn/portal/login.html'
# 初始化浏览器
driver = webdriver.Chrome()
# 访问首页链接
driver.get(index_url)
# 休眠3秒
time.sleep(3)

# # # 截图验证码方法一（python3.6以下会报错）
# # 直接截图标签
# # 定位验证码标签
# captcha_tag = driver.find_element_by_xpath('//*[@id="x-modify"]/div/img[2]')
# # 截图验证码
# captcha_tag.screenshot('captcha.png')

# # 截图验证码方法二
# 先截图全屏幕，再把把对应验证码位置的裁剪出来
# 截图全屏
driver.get_screenshot_as_file("zhijiaoyun.png")
# 首先找到验证码的坐标和图片
captcha_tag : WebElement = driver.find_element_by_xpath('//*[@id="x-modify"]/div/img[2]')
# 左上角坐标
x, y = captcha_tag.location.values()
# 高和宽
height, width = captcha_tag.size.values()
# 用opencv来裁剪图片
img = cv2.imread('./zhijiaoyun.png')
img = img[y:y+height, x:x+width]  # # 裁剪坐标为[y0:y1, x0:x1]
cv2.imwrite('captcha.png',img)

# 关闭浏览器
driver.close()
driver.quit()
```



### 实训二：模拟浏览器在百度设置每页显示条目后搜索

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220524161442324.png" alt="image-20220524161442324" style="zoom:50%;" />

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220524161508932.png" alt="image-20220524161508932" style="zoom:50%;" />



<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220524161539016.png" alt="image-20220524161539016" style="zoom:50%;" />



<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220524161559050.png" alt="image-20220524161559050" style="zoom:50%;" />



```python
#!/usr/bin/env 
# -- coding:utf-8 --

from selenium import webdriver
import time

# 后面是你的浏览器驱动位置，记得前面加r'','r'是防止字符转义的
driver = webdriver.Chrome(r'C:\Program Files\Google\Chrome\Application\chromedriver.exe')
# 用get打开百度页面
driver.get("https://www.baidu.com")
# 查找页面的“设置”选项，并进行点击
driver.find_elements_by_css_selector(r'#s-usersetting-top')[0].click()
time.sleep(2)
# # 打开设置后找到“搜索设置”选项，设置为每页显示50条
driver.find_elements_by_link_text(r'搜索设置')[0].click()
time.sleep(2)

# 选中每页显示50条
m = driver.find_element_by_id('general')
time.sleep(2)
m.find_element_by_xpath('//*[@id="se-setting-3"]/span[3]/span').click()

# 点击保存设置
m.find_element_by_link_text(r'保存设置').click()
#sleep(2)


# 处理弹出的警告页面   确定accept() 和 取消dismiss()
driver.switch_to.alert.accept()
time.sleep(2)

# 找到百度的输入框，并输入 爬虫
driver.find_element_by_id('kw').send_keys('爬虫')
time.sleep(2)
# 点击搜索按钮
driver.find_element_by_id('su').click()
time.sleep(2)
# 在打开的页面中找到“xxxxx”，并打开这个页面
driver.find_element_by_xpath('//*[@id="3003"]/div/div[1]/div/div/h3/div/a').click()
time.sleep(3)

# 关闭浏览器
driver.quit()
```





### 12.2.6  获取当前url

​	我们在用Selenium的时候，是以浏览器跳转的方式，有时候我们也不太清楚跳转到哪个链接了。这时候我们可以通过获取当前url来查看页面的跳转情况。

```python
#  获取本页面URL
print(driver.current_url)
```



### 12.2.7 获取网页源代码（渲染后） -- 重点

​	如果我们不想用Selenium自带的标签解析方法，也可以直接获取渲染过的网页源代码，之后用我们原来学习过的解析方法进行解析。

```python
print(driver.page_source)
```





### 12.2.8 窗口操作(了解，爬虫用不到)

​	平时我们在使用浏览器的时候，是可以控制窗口的大小的，同样的，Selenium也能做到。

​	但是这个在我们爬虫中用不到，一般可以用在自动化测试上。

```python
# 窗口操作(了解，爬虫用不到)
driver.maximize_window()    # 最大化
driver.fullscreen_window()  # 全屏
driver.minimize_window()    # 最小化
driver.get_window_position()    # 获取窗口的坐标
driver.get_window_rect()    # 获取窗口的大小和坐标
driver.get_window_size()    # 获取窗口的大小
driver.set_window_position(100,200)     # 设置窗口的坐标
driver.set_window_rect(100,200,32,50)   # 设置窗口的大小和坐标
driver.set_window_size(400,600)     # 设置窗口的大小
```



### 12.2.9 设置延时

​	平时我们在用浏览器的时候也会发现，当我们打开一个页面的时候，数据是慢慢加载出来的，而我们的程序是非常快的。当我们在爬取数据，如果太快的话，页面数据还没有加载完毕，这时候我们可以设置一个延时时间。

```python
#	设置延时
driver.set_script_timeout(5)  #设置脚本延时五秒后执行
driver.set_page_load_timeout(5)  #设置页面读取时间延时五秒
```





### 12.2.10 前进后退刷新

​	平常使用浏览器的时候，都有前进和后退的功能，Selenium也可以完成这个操作。

```python
driver.refresh()#刷新
driver.back()  #后退
driver.forward() #前进
```



### 12.2.11 执行JS代码 -- 次重点

​	JavaScript控制网页的动态效果，我们也可以写JS语句，让Selenium执行我们的动态效果。

```python
import time

c=webdriver.Chrome(executable_path=r'C:\Program Files\Google\Chrome\Application\chromedriver.exe')
c.get('https://www.baidu.com')
# 执行JS代码
c.execute_script("alert('hello')")
time.sleep(3)
c.quit()
```

​	

​	可以通过JS实现页面向下滚动：

```python
#	在搜索结果页面进行滚轮向下滑动的操作（执行js操作：js注入）
driver.execute_script('window.scrollTo(0,document.body.scrollHeight)')
time.sleep(2)
```



#### 练习3：京东爬虫（向下滚动加载ajax数据）

- 练习题：爬取https://search.jd.com/Search?keyword=%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91&enc=utf-8&wq=%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91&pvid=9670bb8327dc4017b1222a1c0a85e9d6 的全部商品名称（使用selenium）
  - 通过JS向下滚动后，加载Ajax的数据后，爬取全部数据

```python
from selenium import webdriver
import time
# 初始化浏览器
driver = webdriver.Chrome(executable_path=r'C:\Program Files\Google\Chrome\Application\chromedriver.exe')
# 链接
start_url = 'https://search.jd.com/Search?keyword=%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91&enc=utf-8&wq=%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91&pvid=9670bb8327dc4017b1222a1c0a85e9d6'
# 打开初始链接
driver.get(start_url)
# 向下滚动的JS代码
js_code = 'window.scrollTo(0,document.body.scrollHeight)'
driver.execute_script(js_code)
# 休眠3秒等待加载完毕
time.sleep(3)
# 解析li_ls
li_ls = driver.find_elements_by_xpath('//*[@id="J_goodsList"]/ul/li')
# 输出长度
print(len(li_ls))
# 关闭浏览器
driver.close()
driver.quit()
```

![image-20220524123632300](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220524123632300.png)

​	可以通过解析到**li标签**的列表长度发现，selenium连同ajax加载的数据一同提取到了



### 12.2.12 cookie操作

​	使用Selenium，还可以方便地对Cookie进行操作，例如获取、添加、删除等。

```python
#	Cookies操作   --https://www.cnblogs.com/sundahua/p/10202494.html

x = driver.get_cookie('__jda') #获取指定键的Cookies
print(x)   
driver.get_cookies()         #获取所有的Cookies

# driver.delete_cookie('__jda') #删除指定键的Cookies内容
# driver.delete_all_cookies() #删除所有cookies

driver.add_cookie(x) #添加Cookies  
```

​	Selenium其实获取的是完整的Cookie信息，包含了domain，path，source等等........

```
[
{'domain': '.baidu.com', 'expiry': 1685671545, 'httpOnly': False, 'name': 'ZFY', 'path': '/', 'sameSite': 'None', 'secure': True, 'value': 'Hvlgn:BKJe4cE4u56p0M30gjjQI0U1RwT3hM01BiOseU:C'}, {'domain': '.baidu.com', 'expiry': 1654221945, 'httpOnly': False, 'name': 'BA_HECTOR', 'path': '/', 'secure': False, 'value': '2c202k842421a5e08g1h9g6np15'}, {'domain': '.baidu.com', 'expiry': 3801619191, 'httpOnly': False, 'name': 'BAIDUID_BFESS', 'path': '/', 'sameSite': 'None', 'secure': True, 'value': '2F8CD94536AD0BB9900C05247F7D8162:FG=1'},

{'domain': '.baidu.com', 'httpOnly': False, 'name': 'H_PS_PSSID', 'path': '/', 'secure': False, 'value': '36459_36454_31660_36452_35913_36165_36488_36518_36075_36055_36519_26350_36299_36467'}, 

{'domain': '.baidu.com', 'expiry': 1685671544, 'httpOnly': False, 'name': 'BAIDUID', 'path': '/', 'secure': False, 'value': '2F8CD94536AD0BB92EEE82FE56B54D53:FG=1'},

{'domain': '.baidu.com', 'expiry': 3801619191, 'httpOnly': False, 'name': 'BIDUPSID', 'path': '/', 'secure': False, 'value': '2F8CD94536AD0BB9900C05247F7D8162'}, 

{'domain': '.baidu.com', 'expiry': 3801619191, 'httpOnly': False, 'name': 'PSTM', 'path': '/', 'secure': False, 'value': '1654135546'},

{'domain': 'www.baidu.com', 'expiry': 1654999545, 'httpOnly': False, 'name': 'BD_UPN', 'path': '/', 'secure': False, 'value': '12314753'}, 

{'domain': 'www.baidu.com', 'httpOnly': False, 'name': 'BD_HOME', 'path': '/', 'secure': False, 'value': '1'}]
```

​	但我们想要的只有`name`和`value`，并且还有构造成网页头信息看到的格式

![image-20220602100727976](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220602100727976.png)

```python
#!/usr/bin/env python 
# -*- coding: utf-8 -*-
# @Author  : Q
# @Time    : 2022/6/2 10:04
# @Function:
from selenium import webdriver


# 实例化
driver = webdriver.Chrome()
# url
url = 'https://www.baidu.com'
# get
driver.get(url)
# 获取cookies字典列表
cookies_dict_ls = driver.get_cookies()

# # 方式一：采用字符串拼接的方式
# # cookies
# cookies = ''
# # 遍历一下
# for cookies_dict in cookies_dict_ls:
#     # {'domain': '.baidu.com', 'expiry': 1685668544.466202, 'httpOnly': False, 'name': 'ZFY', 'path': '/', 'secure': True, 'value': 'bV7G:AqNVu:BqVJ:Bx8FELY3UYk40b7UzzvJz7hetPra9I:C'}
#     # print(cookies_dict['name'] + '=' + cookies_dict['value'] + '; ')
#
#     # 一条cookie
#     one = cookies_dict['name'] + '=' + cookies_dict['value'] + '; '
#     # 拼接字符串 第一个问题：字符串的连续拼接是不建议的（字符串是不可变类型）
#     # 可变类型去做连续拼接，用列表去改变它
#     cookies += one
#
# # 去尾 第二个问题：还得把最后一个多余的 '; ' 给去掉
# cookies = cookies.strip('; ')
# print(cookies)



# # 方式二：用列表进行拼接

# cookies_ls = []
# # 遍历
# for cookies_dict in cookies_dict_ls:
#     # cookies_dict['name'] + '=' + cookies_dict['value']
#     # 列表是一个可变类型
#     cookies_ls.append(cookies_dict['name'] + '=' + cookies_dict['value'])
#
# cookies = '; '.join(cookies_ls)

# 列表推导式写法
cookies = '; '.join([f'{i["name"]}={i["value"]}' for i in cookies_dict_ls])


# 再去携带头信息
headers = {
    'Cookies': cookies
}


print(headers)

# 关闭浏览器
driver.close()
driver.quit()
```



#### 拓展：职教云模拟登陆后获取个人课程信息

```python
username = ''
password = ''

from selenium import webdriver
import cv2
import requests
import time

from captcha import Chaojiying_Client

# 超级鹰
chaojiying = Chaojiying_Client('用户名', '密码', '933350')

# 初始化浏览器
driver = webdriver.Chrome()
# url
url = 'https://zjy2.icve.com.cn/portal/login.html'
# 访问链接
driver.get(url)
# 验证码标签
captcha_tag = driver.find_element_by_xpath('//*[@id="x-modify"]/div/img[2]')

# # python3.6以下不能对标签截图，如果想直接对标签截图升级到3.7以上
# webElement.screenshot('路径名')
# captcha_tag.screenshot('1.png')


# # python3.6 只能往以下操作去做
# 先把整张网页截图下来
driver.save_screenshot('zhijiaoyun.png')

# element.location 获取标签左上角坐标位置
print(captcha_tag.location)
x, y = captcha_tag.location.values()
# element.size 获取标签的大小（高和宽）
print(captcha_tag.size)
height, width = captcha_tag.size.values()

# 读取图片
origin_img = cv2.imread('zhijiaoyun.png')
img = origin_img[y:y+height,x:x+width]
cv2.imwrite(img=img,filename='captcha.png')

# 输入账号
driver.find_element_by_xpath('//*[@id="login-tabs"]/div/div[1]/div/div[1]/div/input') \
    .send_keys(username)

# 输入密码
driver.find_element_by_xpath('//*[@id="x-modify"]/div/input[1]').send_keys(password)

# 通过超级鹰平台破解验证码
im = open('captcha.png', 'rb').read()
captcha = chaojiying.PostPic(im, 1902).get('pic_str')

# 将验证码输入到验证码框
driver.find_element_by_xpath('//*[@id="x-modify"]/div/input[2]').send_keys(captcha)

# 点击登录
driver.find_element_by_xpath('//*[@id="btnLogin"]').click()

# 休眠一下
time.sleep(5)
# 获取它的cookie
print(driver.get_cookies())

#
cookies_dict_ls = driver.get_cookies()
cookies = '; '.join([f'{cookie["name"]}={cookie["value"]}' for cookie in cookies_dict_ls])

headers = {
    'Cookie': cookies,
    'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.74 Safari/537.36'
}

data = {
    'selectCourse': None
}
# 课程链接
post_url = 'https://zjy2.icve.com.cn/api/teacher/homePage/loadCourseData'

response = requests.post(url=post_url,data=data,headers=headers)
print(response.text)
```

​	requests通过携带Selenium模拟登陆得到的cookies，获取到了课程信息。

![image-20220602100417300](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220602100417300.png)

### 12.2.13 显示等待和隐式等待 

​	在Selenium中，get方法在网页框架加载结束后才会结束执行，如果我们尝试在get方法执行完毕后获取网页源代码，其结构可能并不是浏览器完全加载完成的页面，因为某些页面有额外的Ajax请求，页面还有可能会经过JS渲染。

​	所有，在必要的时候，我们需要设置浏览器延时等待一定的时间，确保节点已经加载出来。

​	一般我们采用的等待方式有三种：强制等待、隐式等待、显式等待。

#### ① 强制等待

​	无论如何，都让程序等待加载，这个方法其实我们前面已经使用过了，就是用time模块的sleep()方法

```python
import time

# 强制等待5秒
time.sleep(5)
```



#### ② 隐式等待

​	设置的全局等待时间。

​	设置等待时间，是对页面中的所有元素设置加载时间，如果超出了设置时间的则抛出异常。隐式等待可以理解成在规定的时间范围内，浏览器在不停的刷新页面，直到找到相关元素或者时间结束。

​	`implicitly_wait()`

```python
from selenium import webdriver

driver = webdriver.Chrome()
# 设置隐式等待，即全局等待时间
driver.implicitly_wait(10)
driver.get("https://www.baidu.com")

# 定位标签，在隐式时间（本例为10秒）内，不断刷新寻找标签，如果超过隐式时间，报错
# 能找到的tag
# tag = driver.find_element_by_xpath('//*[@id="s-hotsearch-wrapper"]/div/a[1]/div/i[1]')
# # 找不到的tag
tag = driver.find_element_by_xpath('//*[@id="s-hotsearch-wrapper"]/div/a[1]/div/i[1]/a')

print(tag)
```



#### ② 显式等待

​	隐式等待的效果其实不好，因为我们只规定了一个固定时间，而页面的加载时间会受网络条件影响。

​	还有一种更合适的等待方式--显示等待，这种方式会指定到要查找的节点和最长等待时间。

​	显示等待是针对于某个特定的元素设置的等待时间，在设置时间内，默认每隔一段时间检测一次当前页面某个元素是否存在，如果在规定的时间内找到了元素，则直接执行，即找到元素就执行相关操作，如果超过设置时间检测不到则抛出异常。默认检测频率为0.5s，默认抛出异常为：NoSuchElementException。

​	显示等待要比隐式等待更加客制化，具体化

```python
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By

driver = webdriver.Chrome()

# 实例化等待类
wait = WebDriverWait(driver, 10)

# 访问百度
driver.get("https://www.baidu.com")

# 能找到的tag
# tag = wait.until(EC.presence_of_element_located((By.XPATH, '//*[@id="s-hotsearch-wrapper"]/div/a[1]/div/i[1]')))

# 找不到的tag
tag = wait.until(EC.presence_of_element_located((By.XPATH, '//*[@id="s-hotsearch-wrapper"]/div/a[1]/div/i[1]/a')))

print(tag)
```



### 12.2.14  无头模式 

​	大家应该已经发现了，上面的案例在运行时，总会弹出有个浏览器窗口，虽然有助于观察页面的爬取情况，但窗口弹来弹去的有时也会造成一些干扰。

​	Chrome浏览器从60版本开始，已经开启了对无头模式的支持，即Headless。

​	在无头模式下，网站运行的时候不会弹出窗口，从而减少了干扰，但同时还减少了一些资源（比如图片）的加载。

​	无头模式在一定程度上节省了资源加载的时间和网络带宽。

```python
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
import time
 
# 创建一个参数对象，用来控制chrome以无界面模式打开
chrome_options = Options()
chrome_options.add_argument('--headless')
 
# 创建浏览器对象
driver = webdriver.Chrome(executable_path='C:\Program Files\Google\Chrome\Application\chromedriver.exe', chrome_options=chrome_options)
 
# 上网
url = 'https://www.baidu.com/'
driver.get(url)
time.sleep(3)
#截图
driver.save_screenshot('baidu.png')
print(browser.page_source)
browser.quit()
```



### 12.2.15 设置代理IP 

​	我们在爬虫的时候，如果爬取的速度太快或者访问过多的时候，往往站点会采取封禁我们IP的方式。

​	针对封IP的反爬，我们可以采用伪装IP的方式破解，在Selenium中设置代理IP的方式如下：

```python
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
option = Options()
ip = '45.190.185.13:3128'
#有的版本是"--proxy-server=https://45.190.185.13:3128"，有的版本是"--proxy-server=45.190.185.13:3128"
option.add_argument(('--proxy-server='+ip))
driver = webdriver.Chrome(executable_path='C:\Program Files\Google\Chrome\Application\chromedriver.exe', chrome_options=option)
driver.get(url='http://httpbin.org/ip')
```





## 12.3 Selenium爬虫



### 实训三：淘宝热卖爬虫

淘宝热卖链接：https://uland.taobao.com/sem/tbsearch?

```python
from selenium import webdriver
from selenium.webdriver.chrome.options import Options


# 淘宝热卖链接
# keyword = 搜索关键词  &   pnum = 页码
base_url = 'https://uland.taobao.com/sem/tbsearch?keyword={}&&pnum={}'

# 关键词
keyword = '电动牙刷'

# 爬取前五页
urls = [base_url.format(keyword,page) for page in range(1,11) ]

# 无头配置
chrome_options = Options()
chrome_options.add_argument('--headless')
chrome_options.add_argument('--disable-gpu')

# 初始化浏览器
driver = webdriver.Chrome(chrome_options=chrome_options)

# 设置隐式等待
driver.implicitly_wait(10)

# 商品列表
good_ls = []

# 遍历前十页
for url in urls:
    # 访问页面
    driver.get(url)
    # 定位所有的Li标签
    li_ls = driver.find_elements_by_xpath('//*[@id="mx_5"]/ul/li')
    # 当li_ls长度不为0的时候
    if len(li_ls):
        for li in li_ls:
            try:
                # 标题
                title = li.find_element_by_xpath('./a/div[1]/span').text
                # 价格
                price = li.find_element_by_xpath('./a/div[2]/span[2]').text
                # 店家
                store = li.find_element_by_xpath('./a/div[3]/div').text

                # 将单个商品添加到商品列表中
                good_ls.append({
                    "标题":title, "价格":price, "店家":store
                })

            except Exception as e:
                print(f"添加失败，失败原因{e.args}")

            else:
                # 输出提示
                print(f"{title}已添加成功")

# 输出最终结果
print(good_ls)
```



### 实训四：惠农网爬虫（面对对象设计）

惠农网链接：https://www.cnhnb.com/

​	首先创建如下的工程，目录结构如下：

![image-20220524155856105](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220524155856105.png)

- \_\_init\__.py：包管理模块
- cnhnb_spider.py：主爬虫程序
- exceptions.py：异常类
- mysql_client.py：数据库管理类
- settings.py：设置



​	\_\_init\__.py

```python
# 惠农网爬虫
```

​	

​	mysql_client.py：数据库管理类

```python
import pymysql
import logging
import re

from settings import MYSQL_CONFIG, TABLE_NAME


class MysqlClinet(object):
    '''
    mysql客户端类
    '''

    # 设置日志
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(message)s')

    def __init__(self):
        '''
        init conn cursor
        '''
        # connection
        self.conn = pymysql.connect(**MYSQL_CONFIG)
        # cursor
        self.cursor = self.conn.cursor()
        # 日志类
        self.logger = logging.getLogger('mysql数据库')


    def drop_table(self, table_name=TABLE_NAME):
        '''
        删表
        :param table_NAME: 表名
        :return: None
        '''
        sql = f'''
            DROP TABLE IF EXISTS {table_name};
        '''
        self.cursor.execute(sql)

        self.logger.info(f"{table_name}删表成功")

        return None


    def create_table(self, table_name=TABLE_NAME):
        # 建表语句
        sql = f'''
            CREATE TABLE IF NOT EXISTS {TABLE_NAME} (
            ID INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
            CODE_ID VARCHAR(50) NOT NULL UNIQUE ,
            CATE_NAME VARCHAR(255) NOT NULL ,
            QTY VARCHAR(255) ,
            SCOPE_FULL_NAME VARCHAR(255),
            LINK_NAME VARCHAR(255)
            );           
        '''
        # 执行建表语句
        self.cursor.execute(sql)

        # 日志
        self.logger.info(f"{table_name}建表成功")

        return None

    def add(self, item, table_name=TABLE_NAME):
        '''
        添加数据
        :param item:添加的数据
        :return: None
        '''
        sql = f'''
            insert into {table_name}(CODE_ID,CATE_NAME,QTY,SCOPE_FULL_NAME,LINK_NAME)
            VALUES(
                "{item['code_id']}","{item['cate_name']}","{item['qty']}",
                "{item['scope_full_name']}","{item['link_name']}"
                );
        '''

        try:
            self.cursor.execute(sql)
            self.conn.commit()

        except Exception as e:
            self.logger.error(f"插入数据失败，失败原因为{e.args}")
            self.conn.rollback()

        else:
            self.logger.info('{}添加成功'.format(item['code_id']))

    def is_exists_table(self,table_name=TABLE_NAME):
        '''
        判断数据表是否存在
        :return: bool
        '''
        sql = 'show tables'

        self.cursor.execute(sql)
        tables = [self.cursor.fetchall()]
        table_list = re.findall('(\'.*?\')', str(tables))
        table_list = [re.sub("'", '', each) for each in table_list]
        if table_name.lower() in table_list or table_name.upper() in table_list:
            return True  # 存在返回true
        else:
            return False  # 不存在返回flase



    def delete(self, code_id, table_name=TABLE_NAME):
        '''
        根据名字删除数据
        :param code: 编号
        :param table_name: 表名
        :return:
        '''
        sql = f'''
            delete from {table_name} where CODE_ID ="{code_id}"
        '''
        try:
            self.cursor.execute(sql)
            self.conn.commit()
        except Exception as e:
            self.conn.rollback()
            self.logger.error(e)
        else:
            self.logger.info(f"{code_id}删除成功")

# 单元测试
if __name__ == "__main__":
    mysql_client = MysqlClinet()
    # mysql_client.drop_table()
    mysql_client.create_table()
    test_item = {"code_id": "175555",
                 'cate_name': "土豆",
                 "qty": "11",
                 'scope_full_name': 'xxxxx',
                 'link_name': 'lcvc',
                 }
    mysql_client.add(test_item)
    mysql_client.delete(code_id="175555")

    print(mysql_client.is_exists_table())
```



​	exceptions.py：异常类

```python
class LineIsEmptyError(Exception):
    def __str__(self):
        '''
        获取行失败
        :return:
        '''
        return repr("该页的行为空")
```



​	settings.py：设置

```python
# MYSQL配置
MYSQL_CONFIG = {
    "host": '127.0.0.1',
    'port': 3306,
    'user': 'root',
    'passwd': 'root',
    'db': 'SPIDER'
}
# 表名
TABLE_NAME = "SCRAPE_HUINONG"

# 头信息
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36 Core/1.77.106.400 QQBrowser/10.9.4626.400'
}

# 总页码
PAGE_COUNT = 10
```



​	cnhnb_spider.py：主爬虫程序

```python
from selenium import webdriver
from retrying import retry
import logging
import time
import re

from mysql_client import MysqlClinet
from settings import HEADERS,PAGE_COUNT
from exceptions import LineIsEmptyError


class FarmProductSpider(object):
    # 实例化配置对象
    options = webdriver.ChromeOptions()
    # 启用无头模式
    options.add_argument('--headless')
    # 禁用GPU
    options.add_argument('--disable-gpu')
    # 伪装UA
    options.add_argument(f'--user-agent={HEADERS["User-Agent"]}')
    # 设置日志
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(message)s')


    def __init__(self):
        '''
        初始化对象
        '''

        # 浏览器对象
        self.driver = webdriver.Chrome(chrome_options=self.options)
        # 基本url
        self.base_url = 'https://www.cnhnb.com/purchase/0-0-0-0-0-{}/'
        # 数据库对象
        self.mysql_client = MysqlClinet()
        # 日志类
        self.logger = logging.getLogger('惠农网爬虫')

    @retry(stop_max_attempt_number=3)
    def jump_page(self,url):
        '''
        用selenium请求网页
        :param url: 网页链接
        :return: None
        '''
        self.driver.get(url=url)
        self.logger.info(f"Crawling {url} ")
        time.sleep(3)
        return

    def get_line(self):
        '''
        :return: 成功 line  失败 None
        '''
        try:
            # 获得每一页的所有行
            line = self.driver.find_elements_by_xpath(
                '//*[@id="__layout"]/div/div/div[2]/div/div[2]/div[2]/ul/li'
            )

            # 判断标准，暂时没有设计的特别好
            if len(line) == 0:
                raise LineIsEmptyError

        except LineIsEmptyError as e:
            # 获取行失败
            self.logger.error(
                f"{self.driver.current_url} 无法获取所有行数据，错误原因{e.args}"
            )
            # 返回None
            return None

        else:
            return line


    def parse_product(self,line):
        '''
        使用xpath提取每一行数据
        :param line: 一行数据
        :yield: item
        '''

        # 商品字典
        item = {}

        # 遍历行
        for li in line:
            '//*[@id="__layout"]/div/div/div[2]/div/div[2]/div[2]/ul/li[1]'
            '//*[@id="__layout"]/div/div/div[2]/div/div[2]/div[2]/ul/li[1]/div/a/div/div[4]'
            try:
                # 采购编码
                code_id = li.find_element_by_xpath('./div/a').get_attribute('href')
                code_id = re.search("\d+",code_id).group(0)
                item['code_id'] = code_id
                # 采购种类
                cate_name = li.find_element_by_xpath('./div/a/div/div[1]').text
                item['cate_name'] = cate_name
                # 采购数量
                qty = li.find_element_by_xpath('./div/a/div/div[2]').text
                item['qty'] = qty
                # 期望货源地址
                scope_full_name = li.find_element_by_xpath('./div/a/div/div[3]').text
                item['scope_full_name'] = scope_full_name
                # 发布人
                link_name = li.find_element_by_xpath('./div/a/div/div[4]').text
                item['link_name'] = link_name

                # 提示
                self.logger.info(f"{code_id}商品解析完毕")

                yield item

            except Exception as e:
                self.logger.error(f"解析行数据失败，失败原因{e.args}")


    def save_data(self,item):
        '''
        将数据保存到数据库中
        :param item: 商品字典
        :return: None
        '''
        self.mysql_client.add(item)
        return None


    def crawl(self):
        '''
        主程序
        :return: None
        '''
        # 没表建表
        if not self.mysql_client.is_exists_table():
            self.mysql_client.create_table()

        # url列表
        urls = [self.base_url.format(page) for page in range(1,PAGE_COUNT+1)]
        # 遍历url列表
        for url in urls:
            self.jump_page(url)
            line = self.get_line()
            if line:
                # 生成器保存的结果
                results = self.parse_product(line)
                # 遍历生成器
                for result in results:
                    # 将数据保存到mysql数据库中
                    self.mysql_client.add(result)



if __name__ == "__main__":

    farm_spider = FarmProductSpider()
    farm_spider.crawl()
```



## 12.4 Selenium滑块验证码模拟登陆  

参考链接：

https://www.baidu.com/link?url=4fDqkqgAQGRgpNE-quzbnTQso-WWoXpCphXV26t6ssxT_N4DbnnkoGTQcxqC2uL6o2eKsps2XqH296AgjbGS_RY74WPHxp16a0bKtI5RU5a&wd=&eqid=9cd0f8240000b3d500000006628d9229

### 12.4.1 动作链

​	在上面的实例中，我们对浏览器的键鼠交互操作都是针对某个节点执行的。

​	例如，对于输入框，首先定位了输入框的标签，调用了它的输入文字方法`kw1.send_keys()`和清空文字方法`kw1.clear()`；对于搜索按钮，我们则是调用它的点击方法`kw1.click()`。

​	其实还有一些操作，它们没有特定的执行对象，比如鼠标拖拽、键盘按键等，这些操作需要用另一种方法执行，那就是动作链。

#### ① 补充：切换Frame

​	在讲动作链之前，我们先补充一个知识点。

​	我们知道，在网页中有一种节点叫做**iframe**，也就是**子Frame**，相当于页面的子页面，它的结构和外部网页的结构完全一致。Selenium打开一个页面后，默认是在**父Frame**里操作，此时这个页面中如果还有子Frame，它是不能获取子Frame里的节点的。

​	这时候就需要使用`.switch_to.frame`方法切换Frame。



​	比如下面这个网站：https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable

![image-20220525093956319](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220525093956319.png)

​	可以看出，**iframe**标签内是一个独立的**html**

![image-20220525094435377](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220525094435377.png)



```python
import time
from selenium import webdriver
from selenium.common.exceptions import NoSuchElementException


# 初始化浏览器
driver = webdriver.Chrome()
# 链接
url = 'https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'
# 访问页面
driver.get(url)

# 提示
print('----------父Frame(默认)----------')

# 父Frame寻找logo //div[@class="logo"]
try:
    driver.find_element_by_xpath('//div[@class="logo"]')
except NoSuchElementException as e:
    print('父Frame中找不到logo')
else:
    print('父Frame中找到logo')

# 父Frame寻找拖拽框  //*[@id="draggable"]
try:
    driver.find_element_by_xpath('//*[@id="draggable"]')
except NoSuchElementException as e:
    print('父Frame找不到拖拽框')
else:
    print('父Frame找到拖拽框')


# 切换到子Frame
# 函数参数为id值
driver.switch_to.frame("iframeResult")
print('----------子Frame(已切换)----------')

# 子Frame寻找logo //div[@class="logo"]
try:
    driver.find_element_by_xpath('//div[@class="logo"]')
except NoSuchElementException as e:
    print('子Frame中找不到logo')
else:
    print('子Frame中找到logo')

# 子Frame寻找拖拽框  //*[@id="draggable"]
try:
    driver.find_element_by_xpath('//*[@id="draggable"]')
except NoSuchElementException as e:
    print('子Frame找不到拖拽框')
else:
    print('子Frame找到拖拽框')


# 切换回父Frame
driver.switch_to.parent_frame()
print('----------切换回父Frame----------')
# 父Frame寻找logo //div[@class="logo"]
try:
    driver.find_element_by_xpath('//div[@class="logo"]')
except NoSuchElementException as e:
    print('父Frame中找不到logo')
else:
    print('父Frame中找到logo')


# 关闭浏览器
driver.quit()
```

![image-20220525100544867](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220525100544867.png)



#### ② 键鼠操作（二）

​	鼠标的拖拽，移动，点击右键等操作，我们在通过标签的操作是无法实现的，所以Selenium给我们提供了一个类来处理这类事件——`ActionChains`。

```python
selenium.webdriver.common.action_chains.ActionChains(driver)
```

​	这个类基本能够满足我们所有对鼠标操作的需求。



**基本用法**

​	首先需要了解ActionChains的执行原理，当你调用ActionChains的方法时，不会立即执行，而是会将所有的操作按顺序存放在一个队列里，当你调用perform()方法时，队列中的时间会依次执行。

​	这种情况下我们可以有两种调用方法：

​	**链式写法**

```python
menu = driver.find_element_by_css_selector(".nav")
hidden_submenu = driver.find_element_by_css_selector(".nav #submenu1")
# 实例化动作链
actions = ActionChains(driver)
# 链式写法：两个动作一次性添加
actions.move_to_element(menu).click(hidden_submenu).perform()
```

​	**分步写法**

```python
menu = driver.find_element_by_css_selector(".nav")
hidden_submenu = driver.find_element_by_css_selector(".nav #submenu1")
# 实例化动作链
actions = ActionChains(driver)
# 添加动作一
actions.move_to_element(menu)
# 添加动作二
actions.click(hidden_submenu)
# 执行队列中的动作一，动作二
actions.perform()
```





**ActionChains类方法列表**

|                            方法名                            |                         用途                         |
| :----------------------------------------------------------: | :--------------------------------------------------: |
|                actions.click(on_element=None)                |                     单击鼠标左键                     |
|         **actions.click_and_hold(on_element=None)**          |               **点击鼠标左键，不松开**               |
|            actions.context_click(on_element=None)            |                     点击鼠标右键                     |
|          **actions.drag_and_drop(source, target)**           |           **将source拖拽到target然后松开**           |
| **actions.drag_and_drop_by_offset(source, xoffset, yoffset)** | **将source向右拖拽xoffset，向下拖拽yoffset然后松开** |
|            actions.double_click(on_element=None)             |                     双击鼠标左键                     |
|         **actions.move_by_offset(xoffset, yoffset)**         |  **鼠标从当前位置向右移动xoffset，向下移动yoffset**  |
|           **actions.move_to_element(to_element)**            |                **鼠标移动到某个元素**                |
| actions.move_to_element_with_offset(to_element, xoffset, yoffset) |     移动到距某个元素（左上角坐标）多少距离的位置     |
|             **actions.release(on_element=None)**             |            **在某个元素位置松开鼠标左键**            |
|                                                              |                                                      |
|                                                              |                                                      |
|            actions.key_down(value, element=None)             |                  按下某个键盘上的键                  |
|             actions.key_up(value, element=None)              |                      松开某个键                      |
|               actions.send_keys(*keys_to_send)               |              发送某个键到当前焦点的元素              |
|     actions.send_keys_to_element(element, *keys_to_send)     |                 发送某个键到指定元素                 |
|                                                              |                                                      |
|                                                              |                                                      |
|                    **actions.perform()**                     |                **执行链中的所有动作**                |





#### 练习4：动作链拖拽滑块

​	比如我们刚刚测试的网站：https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable

​	试着用动作链将【请拖拽我】拖拽到【请放置到这里！】

​                  <img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220525101039631.png" alt="image-20220525101039631" style="zoom:67%;" />



​						<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220525101433574.png" alt="image-20220525101433574" style="zoom:50%;" />



​	方式一：将标签source直接拖拽到标签target位置

​	`actions.drag_and_drop(source, target)`

```python
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
import time


# 初始化浏览器
driver = webdriver.Chrome()
# 链接
url = 'https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'
# 访问链接
driver.get(url)
# 休眠1秒
time.sleep(1)

# 切换到子frame
driver.switch_to.frame('iframeResult')

# 定位【请拖拽我】
source = driver.find_element_by_xpath('//*[@id="draggable"]')

# 定位【请放置到这里】
target = driver.find_element_by_xpath('//*[@id="droppable"]')

# 实例化动作链
actions = ActionChains(driver)

# 添加动作：将source拖拽到target并松开
actions.drag_and_drop(source=source, target=target)
actions.perform()
```





方式二：将标签source按偏移量拖拽

`actions.drag_and_drop_by_offset(source, xoffset, yoffset)`

​	这里最大的问题是如何去计算偏移量，我们假设拖拽的位置是如下这种情况：

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220525115016740.png" alt="image-20220525115016740" style="zoom:50%;" />



​	**xoffset表示x方向的偏移量**

​	**yoffset表示y方向的offset（实际上在网页中y方向是向下的，这里为了好讲解，将y方向向上）**



​	首先我们可以通过`element.location`和`element.size`获取标签左上角的坐标和标签的大小

```python
print(source.location)
print(source.size)
```

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220525120639735.png" alt="image-20220525120639735" style="zoom: 50%;" />



​	拖拽的偏移量无非是从【请拖拽我】的中心坐标拖拽到【请放置到这里】的中心坐标，我们只需要计算出两个方块的中心坐标就可以。

​	有了左上角的坐标，以及它们的宽和高，那么就有了它们中心位置的坐标：

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220525121052002.png" alt="image-20220525121052002" style="zoom: 50%;" />



​	当我们计算出中心位置的坐标，于是乎，`xoffset`和`yoffset`也可以随即得到了。

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220525121432323.png" alt="image-20220525121432323" style="zoom:50%;" />


$$
xoffset =  (x2  + 0.5 *width2) - (x1 + 0.5 * width2)
$$

$$
yoffset = (y2 + 0.5 *height2) - (y1+0.5*height1)
$$



​	于是乎，就有了以下代码：

```python
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
import time


# 初始化浏览器
driver = webdriver.Chrome()
# 链接
url = 'https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'
# 访问链接
driver.get(url)
# 休眠1秒
time.sleep(1)

# 切换到子frame
driver.switch_to.frame('iframeResult')

# 定位【请拖拽我】
source = driver.find_element_by_xpath('//*[@id="draggable"]')
# source.location是source左上角的坐标 {'x': 8, 'y': 8}
x1, y1 = source.location.values()
# source.size是source的大小（高和宽） {'height': 100, 'width': 100}
height1, width1 = source.size.values()

# 定位【请放置到这里】
target = driver.find_element_by_xpath('//*[@id="droppable"]')
x2, y2 = target.location.values()
height2, width2 = target.size.values()


# 计算偏移量
xoffset = (x2 + 0.5 * width2) - (x1 + 0.5 * width1)
yoffset = (y2 + 0.5 * height2) - (y1 + 0.5 * height1)

# 实例化动作链
actions = ActionChains(driver)


# 添加动作：将source按照偏移量拖拽
actions.drag_and_drop_by_offset(source=source, xoffset=xoffset, yoffset=yoffset)
actions.perform()

```





方式三：控制鼠标的方式（推荐方式）

​	动作一：`actions.click_and_hold(on_element=None)` 

​	动作二：`actions.move_by_offset(xoffset, yoffset)`  

​	动作三：`actions.release(on_element=None)`

```python
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
import time


# 初始化浏览器
driver = webdriver.Chrome()
# 链接
url = 'https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'
# 访问链接
driver.get(url)
# 休眠1秒
time.sleep(1)

# 切换到子frame
driver.switch_to.frame('iframeResult')

# 定位【请拖拽我】
source = driver.find_element_by_xpath('//*[@id="draggable"]')
# source.location是source的坐标 {'x': 8, 'y': 8}
x1, y1 = source.location.values()
# source.size是source的大小（高和宽） {'height': 100, 'width': 100}
height1, width1 = source.size.values()

# 定位【请放置到这里】
target = driver.find_element_by_xpath('//*[@id="droppable"]')
x2, y2 = target.location.values()
height2, width2 = target.size.values()


# 计算偏移量
xoffset = (x2 + 0.5 * width2) - (x1 + 0.5 * width1)
yoffset = (y2 + 0.5 * height2) - (y1 + 0.5 * height1)

# 实例化动作链
actions = ActionChains(driver)


# 添加动作一：鼠标左键点击并按住【请拖拽我】
actions.click_and_hold(source)
# 添加动作二：鼠标向offset移动
actions.move_by_offset(xoffset=xoffset, yoffset=yoffset)
# 添加动作三：释放鼠标
actions.release()

# 执行动作
actions.perform()
```

### 12.4.2 匀速滑动和匀加速滑动

​	在前面的案例中，我们都是一次性将滑块拖拽到目标位置，【人】基本不可能做到如此快速的拖拽滑块，有些网站也用这个来检测是否是【人】来进行滑动。

​	所以，我们不能滑动的那么快，我们应该一点一点的将滑块滑动到目标位置，让对方系统分辨不出我们到底是【人】还是【爬虫】。

​	通常，人在操作滑块的时候，一般是先加速拉，然后快到位置的时候减慢，我们可以用一个**匀加速匀减速**的动作去模拟这么一个行为。

#### 练习5：匀速滑动拖拽滑块

​	在讲到**匀加速匀减速**之前，我们先拿一个简单一点的**匀速滑动**来分解：

​	<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220526113128115.png" alt="image-20220526113128115" style="zoom:50%;" />

​	其实匀速运动非常好理解，将整个偏移量均分成n份（本例为6份），每个动作移动一次，一共移动n次就可以做到了。

​	具体代码实现如下：

```python
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
import time


# 初始化浏览器
driver = webdriver.Chrome()
# 链接
url = 'https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'
# 访问链接
driver.get(url)
# 休眠1秒
time.sleep(1)

# 切换到子frame
driver.switch_to.frame('iframeResult')

# 定位【请拖拽我】
source = driver.find_element_by_xpath('//*[@id="draggable"]')
# source.location是source的坐标 {'x': 8, 'y': 8}
x1, y1 = source.location.values()
# source.size是source的大小（高和宽） {'height': 100, 'width': 100}
height1, width1 = source.size.values()

# 定位【请放置到这里】
target = driver.find_element_by_xpath('//*[@id="droppable"]')
x2, y2 = target.location.values()
height2, width2 = target.size.values()


# 计算偏移量
xoffset = (x2 + 0.5 * width2) - (x1 + 0.5 * width1)
yoffset = (y2 + 0.5 * height2) - (y1 + 0.5 * height1)

# 实例化动作链
actions = ActionChains(driver)


# 添加动作：鼠标左键点击并按住【请拖拽我】
actions.click_and_hold(source)
# 添加N个动作，每个动作移动一个部分
n = 6
for i in range(n):
    actions.move_by_offset(xoffset=(xoffset / 6), yoffset=(yoffset / 6) )
# 添加动作：释放鼠标
actions.release()

# 执行动作
actions.perform()

```



#### 练习6：匀加速匀减速拖拽滑块（拟人）

​	在讲解完**匀速**拖动后，我们也能发现，只要设计一个划分，每次按照划分进行移动，就能实现想要的运动方式，那只要我们能设计一个**匀加速匀减速**的划分，就可以实现这个部分。

```python
#设置匀加速匀减速运动
def get_tracks(distance):
    '''
    拿到移动轨迹，模仿人的滑动行为，先匀加速后匀减速
    匀变速运动基本公式：
    ①v=v0+at
    ②s=v0t+½at²
    ③v²-v0²=2as

    :param distance: 需要移动的距离
    :return: 存放每0.5秒移动的距离 动作链大概是0.5秒执行一次
    '''
    # 初速度
    v = 0
    # 单位时间为0.5s来统计轨迹，轨迹即0.5内的位移
    t = 0.5
    # 位移/轨迹列表，列表内的一个元素代表0.5s的位移
    tracks = []
    # 当前的位移
    current = 0
    # 到达mid值开始减速
    mid = distance * 4/5

    while current < distance:
        if current < mid:
            # 加速度越小，模拟的轨迹就越多越详细，但是单位时间的位移越小,速度越慢
            # 加速度越大，模拟的轨迹虽然详细，但是单位时间的位移越大，速度越快
            # 要找到一个比较适合的值
            a = 8
        else:
            a = -12

        # 初速度
        v0=v
        # 0.5秒时间内的位移
        s = v0*t+0.5*a*(t**2)
        # 当前的位置
        current+=s
        # 添加到轨迹列表
        tracks.append(round(s))

        # 速度已经达到v,该速度作为下次的初速度
        v= v0 + a*t
    return tracks
```



​	将匀加速匀减速划分运用到我们的拖拽上：

```python
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
import time


#设置匀加速匀减速运动
def get_tracks(distance):
    '''
    拿到移动轨迹，模仿人的滑动行为，先匀加速后匀减速
    匀变速运动基本公式：
    ①v=v0+at
    ②s=v0t+½at²
    ③v²-v0²=2as

    :param distance: 需要移动的距离
    :return: 存放每0.5秒移动的距离 动作链大概是0.5秒执行一次
    '''
    # 初速度
    v = 0
    # 单位时间为0.5s来统计轨迹，轨迹即0.5内的位移
    t = 0.5
    # 位移/轨迹列表，列表内的一个元素代表0.5s的位移
    tracks = []
    # 当前的位移
    current = 0
    # 到达mid值开始减速
    mid = distance * 4/5

    while current < distance:
        if current < mid:
            # 加速度越小，模拟的轨迹就越多越详细，但是单位时间的位移越小,速度越慢
            # 加速度越大，模拟的轨迹虽然详细，但是单位时间的位移越大，速度越快
            # 要找到一个比较适合的值
            a = 8
        else:
            a = -12

        # 初速度
        v0=v
        # 0.5秒时间内的位移
        s = v0*t+0.5*a*(t**2)
        # 当前的位置
        current+=s
        # 添加到轨迹列表
        tracks.append(round(s))

        # 速度已经达到v,该速度作为下次的初速度
        v= v0 + a*t
    return tracks

# 初始化浏览器
driver = webdriver.Chrome()
# 链接
url = 'https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'
# 访问链接
driver.get(url)
# 休眠1秒
time.sleep(1)

# 切换到子frame
driver.switch_to.frame('iframeResult')

# 定位【请拖拽我】
source = driver.find_element_by_xpath('//*[@id="draggable"]')
# source.location是source的坐标 {'x': 8, 'y': 8}
x1, y1 = source.location.values()
# source.size是source的大小（高和宽） {'height': 100, 'width': 100}
height1, width1 = source.size.values()

# 定位【请放置到这里】
target = driver.find_element_by_xpath('//*[@id="droppable"]')
x2, y2 = target.location.values()
height2, width2 = target.size.values()


# 计算偏移量
xoffset = (x2 + 0.5 * width2) - (x1 + 0.5 * width1)
yoffset = (y2 + 0.5 * height2) - (y1 + 0.5 * height1)

# 实例化动作链
actions = ActionChains(driver)


# 添加动作：鼠标左键点击并按住【请拖拽我】
actions.click_and_hold(source)

# 添加N个动作，每个动作移动一个部分
x_track = get_tracks(xoffset)
y = int(yoffset / len(x_track))
print(y)
for x in x_track:
    actions.move_by_offset(xoffset=x, yoffset=y)

# 添加动作：释放鼠标
actions.release()

# 执行动作
actions.perform()

# 休眠10秒
time.sleep(10)

# 关闭浏览器
driver.close()
driver.quit()
```



### 12.4.3 滑动验证码的模拟登陆

​	在之前的学习中，我们已经学习了数字验证码的识别及其模拟登陆，在Selenium中对数字验证码的模拟登陆更简单，只需要找到输入框，输入账号密码和验证码即可。

​	滑动验证码的破解我们在通常的requests库是没有办法实现的，而且当我们学习完了Selenium之后，我们就可以用动作链的方法模拟鼠标拖拽验证码滑块到指定位置就行了。



### 实训五：滑动验证码模拟登陆

​	测试网站：https://captcha1.scrape.center/

​	测试账户【用户名：admin    密码：admin】

<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220526145748117.png" alt="image-20220526145748117" style="zoom:67%;" />



​	对于这个案例，我们需要综合第十章中对滑块验证码的缺口识别，加上本章中操控Selenium对滑块的拖拽。



​	首先把图像识别类定义好

```python
import cv2


class TargetRecognize(object):
    '''
        识别滑动验证码的缺口位置
    '''
    # 高斯核大小
    GAUSS_KERNEL_SIZE = (5, 5)
    # 高斯X方向标准差
    GAUSS_SIGMA_X = 0
    # 边缘检测的最小最大阈值
    THRESHOLD1 = 150
    THRESHOLD2 = 200

    def __init__(self, img_path):
        '''
        初始化
        :param img_path: 要识别的图片路径名
        '''
        # 读取图片
        self.img = cv2.imread(img_path)
        # # 图片尺寸
        self.img_height, self.img_width, _ = self.img.shape
        # 设置最初偏移量为None
        self.offset = None



    def get_grey_img(self,img):
        '''
        :return: 灰度图
        '''
        return cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    def get_gauss_img(self,img):
        '''
        :return:高斯滤波图
        '''
        return cv2.GaussianBlur(img, ksize=self.GAUSS_KERNEL_SIZE,
                                sigmaX=self.GAUSS_SIGMA_X)

    def get_canny_img(self,img):
        '''
        :return: 边缘检测图
        '''
        return cv2.Canny(img, threshold1=self.THRESHOLD1,
                         threshold2=self.THRESHOLD2)

    def get_contours(self,img):
        '''
        :return: contours
        '''
        contours, _ = cv2.findContours(img, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)
        return contours

    def get_area_threshold(self):
        '''
        :return: 面积阈值
        '''
        contour_area_min = (self.img_width * 0.15) * (self.img_height * 0.25) * 0.8
        contour_area_max = (self.img_width * 0.15) * (self.img_height * 0.25) * 1.2
        return contour_area_min, contour_area_max

    def get_arc_length_threshold(self):
        '''
        :return: 周长阈值
        '''
        arc_length_min = 2 * ((self.img_width * 0.15) + (self.img_height * 0.25)) * 0.8
        arc_length_max = 2 * ((self.img_width * 0.15) + (self.img_height * 0.25)) * 1.2
        return arc_length_min, arc_length_max

    def get_offset_threshold(self):
        '''
        :return: 偏移量阈值
        '''
        offset_min = 0.2 * self.img_width
        offset_max = 0.85 * self.img_width
        return offset_min, offset_max

    def run(self):
        '''
        :return: 缺口的偏移量
        '''

        grey_img = self.get_grey_img(self.img)
        gauss_img = self.get_gauss_img(grey_img)
        canny_img = self.get_canny_img(gauss_img)

        contours = self.get_contours(canny_img)

        contour_area_min, contour_area_max = self.get_area_threshold()
        arc_length_min, arc_length_max = self.get_arc_length_threshold()
        offset_min, offset_max = self.get_offset_threshold()

        # 遍历所有的轮廓信息
        for contour in contours:
            # 每个轮廓外接矩阵的四个点坐标
            x, y, w, h = cv2.boundingRect(contour)

            # 判断条件
            if (contour_area_min < cv2.contourArea(contour) < contour_area_max) and \
                    (arc_length_min < cv2.arcLength(contour,True) < arc_length_max) and \
                    (offset_min < x < offset_max):
                # 当满足条件时
                self.offset = x
                # 返回缺口偏移量

                return self.offset
```

​	接下来，我们编写主要程序来识别验证码的主程序：

```python
from selenium import webdriver
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.common.action_chains import ActionChains
import time

from target_recognize import TargetRecognize


class SliderLanding(object):
    '''
        用于滑动验证码的登陆
    '''

    # 账号
    USERNAME = 'admin'
    # 密码
    PASSWORD = 'admin'
    # 登陆链接
    INDEX_URL = 'https://captcha1.scrape.center/'

    def __init__(self):
        # 初始化浏览器
        self.driver = webdriver.Chrome()
        # 本地验证码图片地址
        self.img_path = 'captcha.png'
        # 初始化动作链
        self.actions = ActionChains(self.driver)

    def get_index_url(self):
        # 访问登陆页面
        self.driver.get(self.INDEX_URL)

    def login_in(self):
        '''
        输入账户密码
        :return: bool
        '''
        try:
            # 输入账户
            self.driver.find_element_by_xpath('//*[@id="app"]/div[2]/div/div/div/div/div/form/div[1]/div/div/input') \
                .send_keys(self.USERNAME)
            # 输入密码
            self.driver.find_element_by_xpath('//*[@id="app"]/div[2]/div/div/div/div/div/form/div[2]/div/div/input') \
                .send_keys(self.PASSWORD)
            # 休眠十秒
            time.sleep(10)
            # 点击登陆
            self.driver.find_element_by_xpath('//*[@id="app"]/div[2]/div/div/div/div/div/form/div[3]/div/button'). \
                click()

            # 查看是否跳转到验证码画面
            self.driver.find_element_by_xpath('//div[@class="geetest_panel_next"]')

        except NoSuchElementException as e:

            return False

        else:
            return True

    def download_captcha(self):
        '''
        下载验证码图片
        :return:
        '''
        time.sleep(5)
        self.driver.find_element_by_xpath('//canvas[@class="geetest_canvas_slice geetest_absolute"]').\
            screenshot(self.img_path)

    # 设置匀加速匀减速运动
    def get_tracks(self,distance):
        '''
        拿到移动轨迹，模仿人的滑动行为，先匀加速后匀减速
        匀变速运动基本公式：
        ①v=v0+at
        ②s=v0t+½at²
        ③v²-v0²=2as

        :param distance: 需要移动的距离
        :return: 存放每0.5秒移动的距离 动作链大概是0.5秒执行一次
        '''
        # 初速度
        v = 0
        # 单位时间为0.5s来统计轨迹，轨迹即0.5内的位移
        t = 0.5
        # 位移/轨迹列表，列表内的一个元素代表0.5s的位移
        tracks = []
        # 当前的位移
        current = 0
        # 到达mid值开始减速
        mid = distance * 4 / 5

        while current < distance:
            if current < mid:
                # 加速度越小，模拟的轨迹就越多越详细，但是单位时间的位移越小,速度越慢
                # 加速度越大，模拟的轨迹虽然详细，但是单位时间的位移越大，速度越快
                # 要找到一个比较适合的值
                a = 1
            else:
                a = -1

            # 初速度
            v0 = v
            # 0.5秒时间内的位移
            s = v0 * t + 0.5 * a * (t ** 2)
            # 当前的位置
            current += s
            # 添加到轨迹列表
            tracks.append(round(s))

            # 速度已经达到v,该速度作为下次的初速度
            v = v0 + a * t
        return tracks


    def move_slider(self, distance):
        '''
        滑动滑块
        :return:
        '''
        # 滑块标签
        slider_tag = self.driver.find_element_by_xpath('/html/body/div[2]/div[2]/div[6]/div/div[1]/div[2]/div[2]')
        # 获取匀加速匀减速轨道
        x_tracks = self.get_tracks(distance)
        # 添加点击保持动作
        self.actions.click_and_hold(slider_tag)
        # 依次添加匀加速匀减速动作
        for x in x_tracks:
            self.actions.move_by_offset(xoffset=x, yoffset=0)
        # 添加释放鼠标动作
        self.actions.release()
        # 执行动作
        self.actions.perform()

    def run(self):
        '''
        :return: cookies
        '''

        self.get_index_url()
        if self.login_in():
            self.download_captcha()
            target_recognize = TargetRecognize(self.img_path)
            distance = target_recognize.run()
            if distance:
                self.move_slider(distance)
            else:
                print("识别图片失败")
        else:
            print('登陆失败')
            
            
        return self.driver.get_cookies()

if __name__ == '__main__':
    slider_landing = SliderLanding()
    slider_landing.run()

```

​	可惜，这个网站要求的准确率非常高，用一般opencv方法达不到这么高的确切率，一般会有一点偏差，基本上大部分都失败了，比如如下：

![image-20220526162947385](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220526162947385.png)

​	如果想要追求更高的准确率，请用深度学习模型（比如YOLO5）

### 实训六：豆瓣模拟登陆（自己注册账号）

​	豆瓣的滑动验证码相对就不需要这么高的准确率。

​	一样的，首先是滑块验证码识别类

```python
import cv2


class TargetRecognize(object):
    '''
        识别滑动验证码的缺口位置
    '''
    # 高斯核大小
    GAUSS_KERNEL_SIZE = (5, 5)
    # 高斯X方向标准差
    GAUSS_SIGMA_X = 0
    # 边缘检测的最小最大阈值
    THRESHOLD1 = 150
    THRESHOLD2 = 400

    def __init__(self, img_path):
        '''
        初始化
        :param img_path: 要识别的图片路径名
        '''
        # 读取图片
        self.img = cv2.imread(img_path)
        # # 图片尺寸
        self.img_height, self.img_width, _ = self.img.shape
        # 设置最初偏移量为None
        self.distance = None



    def get_grey_img(self,img):
        '''
        :return: 灰度图
        '''
        return cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    def get_gauss_img(self,img):
        '''
        :return:高斯滤波图
        '''
        return cv2.GaussianBlur(img, ksize=self.GAUSS_KERNEL_SIZE,
                                sigmaX=self.GAUSS_SIGMA_X)

    def get_canny_img(self,img):
        '''
        :return: 边缘检测图
        '''
        return cv2.Canny(img, threshold1=self.THRESHOLD1,
                         threshold2=self.THRESHOLD2)

    def get_contours(self,img):
        '''
        :return: contours
        '''
        contours, _ = cv2.findContours(img, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)
        return contours

    def get_area_threshold(self):
        '''
        :return: 面积阈值
        '''
        contour_area_min = (self.img_width * 0.1) * (self.img_height * 0.3) * 0.8
        contour_area_max = (self.img_width * 0.1) * (self.img_height * 0.3) * 1.2
        return contour_area_min, contour_area_max

    def get_arc_length_threshold(self):
        '''
        :return: 周长阈值
        '''
        arc_length_min = 2 * ((self.img_width * 0.1) + (self.img_height * 0.3)) * 0.8
        arc_length_max = 2 * ((self.img_width * 0.1) + (self.img_height * 0.3)) * 1.2
        return arc_length_min, arc_length_max

    def get_offset_threshold(self):
        '''
        :return: 偏移量阈值
        '''
        offset_min = 0.3 * self.img_width
        offset_max = 0.9 * self.img_width
        return offset_min, offset_max

    def run(self):
        '''
        :return: 缺口的偏移量
        '''

        grey_img = self.get_grey_img(self.img)
        gauss_img = self.get_gauss_img(grey_img)
        canny_img = self.get_canny_img(gauss_img)

        contours = self.get_contours(canny_img)

        contour_area_min, contour_area_max = self.get_area_threshold()
        arc_length_min, arc_length_max = self.get_arc_length_threshold()
        offset_min, offset_max = self.get_offset_threshold()

        # 遍历所有的轮廓信息
        for contour in contours:
            # 每个轮廓外接矩阵的四个点坐标
            x, y, w, h = cv2.boundingRect(contour)

            # 判断条件
            if (contour_area_min < cv2.contourArea(contour) < contour_area_max) and \
                    (arc_length_min < cv2.arcLength(contour,True) < arc_length_max) and \
                    (offset_min < x < offset_max):
                # 当满足条件时
                self.distance = x
                # 返回缺口偏移量
                # 由于识别效果的问题，这里最好减个10
                return self.distance



if __name__ == "__main__":
    target_recognize = TargetRecognize(img_path='./captcha.png')
    print(target_recognize.run())
```

​	接下来是豆瓣滑块登陆

```python
from selenium import webdriver
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.common.action_chains import ActionChains
import time

from target_recognize import TargetRecognize


class SliderLanding(object):
    '''
        用于滑动验证码的登陆
    '''

    # 账号
    USERNAME = '自己注册用户名'
    # 密码
    PASSWORD = '密码'
    # 登陆链接
    INDEX_URL = 'https://www.douban.com/'

    def __init__(self):
        # 初始化浏览器
        self.driver = webdriver.Chrome()
        # 本地验证码图片地址
        self.img_path = 'captcha.png'
        # 初始化动作链
        self.actions = ActionChains(self.driver)

    def get_index_url(self):
        # 访问登陆页面
        self.driver.get(self.INDEX_URL)

    def login_in(self):
        '''
        输入账户密码
        :return: bool
        '''
        try:
            self.driver.switch_to.frame(0)
            # 点击【密码登陆】
            self.driver.find_element_by_xpath('/html/body/div[1]/div[1]/ul[1]/li[2]').click()
            # 输入账户
            self.driver.find_element_by_xpath('//*[@id="username"]').send_keys(self.USERNAME)
            # 输入密码
            self.driver.find_element_by_xpath('//*[@id="password"]').send_keys(self.PASSWORD)
            # 点击登陆
            self.driver.find_element_by_xpath('/html/body/div[1]/div[2]/div[1]/div[5]/a') \
                .click()


            # 休眠5秒
            time.sleep(5)

            # 切换到子frame
            iframe_captcha = self.driver.find_element_by_xpath('//*[@id="tcaptcha_iframe"]')  # 验证码frame
            self.driver.switch_to.frame(iframe_captcha)

            # 查看是否跳转到验证码画面
            self.driver.find_element_by_xpath('//*[@id="slideBlockWrap"]')

        except NoSuchElementException as e:

            return False

        else:
            return True

    def download_captcha(self):
        '''
        下载验证码图片
        :return:
        '''
        self.driver.find_element_by_xpath('//*[@id="slideBgWrap"]').screenshot(self.img_path)

    # 设置匀加速匀减速运动
    def get_tracks(self,distance):
        '''
        拿到移动轨迹，模仿人的滑动行为，先匀加速后匀减速
        匀变速运动基本公式：
        ①v=v0+at
        ②s=v0t+½at²
        ③v²-v0²=2as

        :param distance: 需要移动的距离
        :return: 存放每0.5秒移动的距离 动作链大概是0.5秒执行一次
        '''
        # 初速度
        v = 0
        # 单位时间为0.5s来统计轨迹，轨迹即0.5内的位移
        t = 0.5
        # 位移/轨迹列表，列表内的一个元素代表0.5s的位移
        tracks = []
        # 当前的位移
        current = 0
        # 到达mid值开始减速
        mid = distance * 4 / 5

        while current < distance:
            if current < mid:
                # 加速度越小，模拟的轨迹就越多越详细，但是单位时间的位移越小,速度越慢
                # 加速度越大，模拟的轨迹虽然详细，但是单位时间的位移越大，速度越快
                # 要找到一个比较适合的值
                a = 4
            else:
                a = -6

            # 初速度
            v0 = v
            # 0.5秒时间内的位移
            s = v0 * t + 0.5 * a * (t ** 2)
            # 当前的位置
            current += s
            # 添加到轨迹列表
            tracks.append(round(s))

            # 速度已经达到v,该速度作为下次的初速度
            v = v0 + a * t
        return tracks


    def move_slider(self, distance):
        '''
        滑动滑块
        :return:
        '''
        # 滑块标签
        slider_tag = self.driver.find_element_by_xpath('//*[@id="tcaptcha_drag_thumb"]')
        # 获取匀加速匀减速轨道
        x_tracks = self.get_tracks(distance)
        # 添加点击保持动作
        self.actions.click_and_hold(slider_tag)
        # 依次添加匀加速匀减速动作
        for x in x_tracks:
            self.actions.move_by_offset(xoffset=x, yoffset=0)
        # 添加释放鼠标动作
        self.actions.release()
        # 执行动作
        self.actions.perform()

    def close_drive(self):
        '''
        关闭浏览器
        :return:
        '''
        time.sleep(5)
        self.driver.close()
        self.driver.quit()


    def run(self):
        '''
        :return: cookies
        '''

        self.get_index_url()
        if self.login_in():
            self.download_captcha()
            target_recognize = TargetRecognize(self.img_path)
            distance = target_recognize.run()
            if distance:
                # 由于豆瓣的滑块不是从开头开始，我们要减去第一个滑块的坐标
                distance -= self.driver.find_element_by_xpath('//*[@id="slideBlock"]').location.get("x")
                self.move_slider(distance)
            else:
                print("识别图片失败")
        else:
            print('登陆失败')

        return self.driver.get_cookies()


if __name__ == '__main__':
    slider_landing = SliderLanding()
    slider_landing.run()
```

​	这里验证码检测的参数还没有调好，检测效果不是太好，豆瓣的话可以用另外一个方法图片匹配方法，因为它的滑块是单独的一个图片，可以把这个图片做一个缺口检测。



![image-20220530092318289](C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220530092318289.png)



<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220526173827178.png" alt="image-20220526173827178" style="zoom:50%;" />



<img src="C:\Users\ACG1314\AppData\Roaming\Typora\typora-user-images\image-20220526173848722.png" alt="image-20220526173848722" style="zoom:67%;" />

```python
import cv2
import numpy as np

# 使用opencv模块 计算缺口的偏移值
def get_image_offset(back_image_path, slider_image_path ):

    # 获取图片并灰度化
    block = cv2.imread(slider_image_path, 0)
    template = cv2.imread(back_image_path, 0)
    w, h = block.shape[::-1]
    print(w, h)
    # 二值化后图片名称
    block_name = 'block.jpg'
    template_name = 'template.jpg'
    # 保存二值化后的图片
    cv2.imwrite(block_name, block)
    cv2.imwrite(template_name, template)
    block = cv2.imread(block_name)
    block = cv2.cvtColor(block, cv2.COLOR_RGB2GRAY)
    block = abs(255 - block)
    cv2.imwrite(block_name, block)
    block = cv2.imread(block_name)
    template = cv2.imread(template_name)
    # 获取偏移量
    # 模板匹配，查找block在template中的位置，返回result是一个矩阵，是每个点的匹配结果
    result = cv2.matchTemplate(block, template, cv2.TM_CCOEFF_NORMED)
    x, y = np.unravel_index(result.argmax(), result.shape)
    print(x, y)
    # 由于获取到的验证码图片像素与实际的像素有差(实际：280*158 原图：680*390)，故对获取到的坐标进行处理
    offset = y * (280 / 680)
    # 画矩形圈出匹配的区域
    # 参数解释：1.原图 2.矩阵的左上点坐标 3.矩阵的右下点坐标 4.画线对应的rgb颜色 5.线的宽度
    cv2.rectangle(template, (y, x), (y + w, x + h), (7, 249, 151), 2)
    #show(template)
    return offset


# # 显示图片
def show(name):
    cv2.imshow('Show', name)
    cv2.waitKey(0)
    cv2.destroyAllWindows()


if __name__ == '__main__':

    print(get_image_offset('back_image.jpg','slider_image.jpg'))
```

​		爬虫主程序

```python
from selenium import webdriver
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.common.action_chains import ActionChains
import time
import requests

from get_image_offset import get_image_offset


class SliderLanding(object):
    '''
        用于滑动验证码的登陆
    '''

    # 账号
    USERNAME = '15078270164'
    # 密码
    PASSWORD = '980604'
    # 登陆链接
    INDEX_URL = 'https://www.douban.com/'

    def __init__(self):
        # 初始化浏览器
        self.driver = webdriver.Chrome()
        # 本地滑块图片地址
        self.slider_image_path = './block.jpg'
        self.back_image_path = './template.jpg'
        # 初始化动作链
        self.actions = ActionChains(self.driver)

    def get_index_url(self):
        # 访问登陆页面
        self.driver.get(self.INDEX_URL)

    def login_in(self):
        '''
        输入账户密码
        :return: bool
        '''
        try:
            self.driver.switch_to.frame(0)
            # 点击【密码登陆】
            self.driver.find_element_by_xpath('/html/body/div[1]/div[1]/ul[1]/li[2]').click()
            # 输入账户
            self.driver.find_element_by_xpath('//*[@id="username"]').send_keys(self.USERNAME)
            # 输入密码
            self.driver.find_element_by_xpath('//*[@id="password"]').send_keys(self.PASSWORD)
            # 点击登陆
            self.driver.find_element_by_xpath('/html/body/div[1]/div[2]/div[1]/div[5]/a') \
                .click()


            # 休眠5秒
            time.sleep(5)

            # 切换到子frame
            iframe_captcha = self.driver.find_element_by_xpath('//*[@id="tcaptcha_iframe"]')  # 验证码frame
            self.driver.switch_to.frame(iframe_captcha)

            # 查看是否跳转到验证码画面
            self.driver.find_element_by_xpath('//*[@id="slideBlockWrap"]')

        except NoSuchElementException as e:

            return False

        else:
            return True

    def download_captcha(self):
        '''
        这里要下载两个图片，一个是滑块图片，一个是验证码图片
        这是豆瓣比较特殊的地方
        :return:
        '''
        slide_img_src = self.driver.find_element_by_xpath('//*[@id="slideBlock"]').get_attribute('src')
        back_img_src = self.driver.find_element_by_xpath('//*[@id="slideBg"]').get_attribute('src')
        with open(self.back_image_path,'wb') as fp:
            fp.write(requests.get(back_img_src).content)
        with open(self.slider_image_path,'wb') as fp:
            fp.write(requests.get(slide_img_src).content)

    # 设置匀加速匀减速运动
    def get_tracks(self,distance):
        '''
        拿到移动轨迹，模仿人的滑动行为，先匀加速后匀减速
        匀变速运动基本公式：
        ①v=v0+at
        ②s=v0t+½at²
        ③v²-v0²=2as

        :param distance: 需要移动的距离
        :return: 存放每0.5秒移动的距离 动作链大概是0.5秒执行一次
        '''
        # 初速度
        v = 0
        # 单位时间为0.5s来统计轨迹，轨迹即0.5内的位移
        t = 0.5
        # 位移/轨迹列表，列表内的一个元素代表0.5s的位移
        tracks = []
        # 当前的位移
        current = 0
        # 到达mid值开始减速
        mid = distance * 4 / 5

        while current < distance:
            if current < mid:
                # 加速度越小，模拟的轨迹就越多越详细，但是单位时间的位移越小,速度越慢
                # 加速度越大，模拟的轨迹虽然详细，但是单位时间的位移越大，速度越快
                # 要找到一个比较适合的值
                a = 2
            else:
                a = -3

            # 初速度
            v0 = v
            # 0.5秒时间内的位移
            s = v0 * t + 0.5 * a * (t ** 2)
            # 当前的位置
            current += s
            # 添加到轨迹列表
            tracks.append(round(s))

            # 速度已经达到v,该速度作为下次的初速度
            v = v0 + a * t
        return tracks


    def move_slider(self, distance):
        '''
        滑动滑块
        :return:
        '''
        # 滑块标签
        slider_tag = self.driver.find_element_by_xpath('//*[@id="tcaptcha_drag_thumb"]')
        # 获取匀加速匀减速轨道
        x_tracks = self.get_tracks(distance)
        # 添加点击保持动作
        self.actions.click_and_hold(slider_tag)
        # 依次添加匀加速匀减速动作
        for x in x_tracks:
            self.actions.move_by_offset(xoffset=x, yoffset=0)
        # 添加释放鼠标动作
        self.actions.release()
        # 执行动作
        self.actions.perform()

    def close_drive(self):
        '''
        关闭浏览器
        :return:
        '''
        time.sleep(5)
        self.driver.close()
        self.driver.quit()


    def run(self):
        '''
        :return: cookies
        '''

        self.get_index_url()
        if self.login_in():
            self.download_captcha()
            distance = get_image_offset(self.back_image_path, self.slider_image_path)
            if distance:
                # 由于豆瓣的滑块不是从开头开始，我们要减去第一个滑块的坐标
                distance -= self.driver.find_element_by_xpath('//*[@id="slideBlock"]').location.get("x")
                self.move_slider(distance)
            else:
                print("识别图片失败")
        else:
            print('登陆失败')

        return self.driver.get_cookies()


if __name__ == '__main__':
    slider_landing = SliderLanding()
    slider_landing.run()
```



## 12.5  如何让selenium规避检测 

​	现在有很多网站增加了对Selenium的检测，防止一些爬虫的恶意爬取，如果检测到有人使用Selenium打开浏览器，就直接屏蔽。

​	所以我们得想办法去反屏蔽针对网站对Selenium的检测。

### 12.5.1 设置端口打开浏览器

​	Selenium自动化工具其实是借用驱动程序去操作浏览器，我们之前的操作都是直接用Selenium打开浏览器后再操作浏览器，这时候浏览器就会自动提示【浏览器正在受自动化测试工具操控】。由于浏览器是Selenium打开的，所以导致被检测到。

​	那么如果我们手动打开浏览器，然后再用Selenium去操控它，这时候就不会被检测到了。

​	我们有一条命令是在指定端口可以打开chrome浏览器，然后再让Selenium接管该端口的浏览器。



- 规避检测的方法：

  - selenium接管chrome浏览器

- 实现步骤

  - 1.必须将你电脑中安装的**谷歌浏览器的程序（注意不是谷歌驱动的位置）**所在的目录找到。且将目录添加到环境变量中。

    ![image-20230516200846337](./F:/学院杂物/主要文件夹--2023年第1学期/2023_网络爬虫/网络爬虫实训手册/assets/image-20230516200846337.png)

  - 2.打开cmd，在命令行中输入命令：

    - chrome.exe --remote-debugging-port=9222 --user-data-dir="一个空文件夹的目录"（在Python有模块能实现输入操作系统命令，比如`os模块`，`Popen模块`）
    - 指定执行结束后，会打开你本机安装好的谷歌浏览器。

  - 3.执行如下代码：可以使用下属代码接管步骤2打开的真实的浏览器

```python
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
 
chrome_options = Options()
# 接管 127.0.0.1:9222的谷歌浏览器
chrome_options.add_experimental_option("debuggerAddress", "127.0.0.1:9222")
#本机安装好谷歌的驱动程序路径
chrome_driver = "C:\Program Files\Google\Chrome\Application\chromedriver.exe"

driver = webdriver.Chrome(executable_path=chrome_driver,chrome_options=chrome_options)
print(driver.title)
# # 以前今日头条还有反屏蔽设置，现在好像没有了
# toutiao_url = 'https://www.toutiao.com/ch/news_entertainment/'
# driver.get(toutiao_url)

# 另一个会屏蔽selenium的网站
url = 'https://antispider1.scrape.center/'
driver.get(url)
```



### 12.5.2 伪装window.navigator对象

​	在大多数情况下，检测的基本原理是检测当前浏览器窗口的window.navigator对象中是否包含webdriver属性。因为在正常使用浏览器时，这个属性应该是undefined，一旦使用Selenium，它就会给window.navigatord对象设置webdriver属性。

​	很多网站都是通过JavaScript语句判断是否存在webdriver属性，如果存在就直接屏蔽。

​	

【失败方法】当然我们也学过可以用JavaScript语句把webdriver属性置空，调用如下语句：

```python
driver.execute_script('Object.defineProperty(navigator,"webdriver",{get:()=>undefined})')
```

​	虽然这行代码可以把webdriver属性置空，但是execute_script方法是在页面加载完毕之后才调用的，已经为时已晚，网页在渲染前就已经检测webdriver属性了。



【成功方法】在Selenium中，可以用CDP（即Chrome Devtools Protocol，Chrome开发工具协议）解决这个问题，利用它可以实现在每个页面刚加载的时候执行JavaScript语句，将webdriver属性置空。

​	这里执行的CDP方法叫做`Page.addScriptToEvaluateOnNewDocument`。

​	实现代码如下：

```python
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

# 实例化设置类
options = Options()
# 添加设置--隐藏【浏览器正在被自动化测试工具操控】
options.add_experimental_option('excludeSwitches', ['enable-automation'])
options.add_experimental_option('useAutomationExtension', False)
#  实例化浏览器对象
driver = webdriver.Chrome(chrome_options=options)
# 反屏蔽测试链接
url = 'https://antispider1.scrape.center/'
# 设置CDP
driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
    'source': 'Object.defineProperty(navigator, "webdriver", {get: ()=> undefined})'
})
# 访问链接
driver.get(url)
```

